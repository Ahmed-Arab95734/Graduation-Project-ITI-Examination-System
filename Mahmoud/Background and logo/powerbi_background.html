<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Power BI Background — Navy to Red Network</title>
  <style>
    /* Full-bleed canvas that can be exported or used as a background image */
    html,body{
      height:100%;
      margin:0;
    }
    .bg-wrap{
      position:relative;
      width:100%;
      height:100vh; /* fits the browser viewport — export at desired resolution */
      overflow:hidden;
      background: linear-gradient(120deg, #0f2b39 0%, #2b2230 35%, #5a1e20 70%, #7b1414 100%);
      /* subtle vignette and noise-like overlay provided by pseudo elements */
      display:block;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* A softly blurred radial glow in lower-left to mimic the original */
    .bg-wrap::before{
      content:'';
      position:absolute;
      left:-20%;
      bottom:-10%;
      width:1200px;
      height:1200px;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.06), rgba(255,255,255,0) 25%);
      filter: blur(30px);
      pointer-events:none;
    }

    /* Subtle dark overlay to keep content readable */
    .bg-wrap::after{
      content:'';
      position:absolute;
      inset:0;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0.0) 10%, rgba(0,0,0,0.25) 100%);
      pointer-events:none;
    }

    svg.network{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      display:block;
      pointer-events:none; /* so it doesn't block clicks if used inside Power BI web view */
    }

    /* thin lines across the composition */
    .network-line{
      stroke: rgba(255,255,255,0.08);
      stroke-width:1.6;
      stroke-linecap:round;
    }

    /* subtle, fainter secondary lines */
    .network-line.faint{
      stroke: rgba(255,255,255,0.03);
      stroke-width:1;
    }

    .node-glow{
      fill: rgba(255,255,255,0.9);
      opacity:0.85;
      filter: url(#softGlow);
    }

    /* responsiveness for export: keep 16:9 in big screens */
    @media (min-aspect-ratio: 16/9){
      .bg-wrap{height:56.25vw;}
    }
  </style>
</head>
<body>
  <div class="bg-wrap" id="bg">
    <svg class="network" id="networkSvg" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="none">
      <!-- glow filter -->
      <defs>
        <filter id="softGlow" x="-50%" y="-50%" width="200%" height="200%">
          <feGaussianBlur stdDeviation="8" result="blur" />
          <feMerge>
            <feMergeNode in="blur" />
            <feMergeNode in="SourceGraphic" />
          </feMerge>
        </feMerge>
        </filter>
      </defs>
      <!-- lines and nodes will be generated by JS -->
    </svg>
  </div>

  <script>
    // Generate a network of lines and a few glowing nodes. The result is deterministic but responsive.
    (function(){
      const svg = document.getElementById('networkSvg');
      let width, height;

      function rand(seed){
        // simple pseudo-random generator for deterministic output
        let x = Math.sin(seed++) * 10000;
        return x - Math.floor(x);
      }

      function createLayout(){
        svg.innerHTML = svg.querySelector('defs')?.outerHTML || '';
        width = svg.clientWidth || window.innerWidth;
        height = svg.clientHeight || window.innerHeight;

        // choose a set of anchor points positioned across the canvas
        const anchors = [];
        const cols = 6;
        const rows = 4;
        let counter = 1;
        for(let r=0;r<rows;r++){
          for(let c=0;c<cols;c++){
            // distribute with some randomness
            const nx = (c + 0.2 + 0.6 * Math.abs(Math.sin(counter))) / (cols - 1 + 0.6);
            const ny = (r + 0.1 + 0.6 * Math.abs(Math.cos(counter))) / (rows - 1 + 0.6);
            anchors.push({
              x: Math.round(nx * width),
              y: Math.round(ny * height)
            });
            counter++;
          }
        }

        // draw faint diagonal lines that cross the canvas
        for(let i=0;i<anchors.length;i++){
          for(let j=i+1;j<anchors.length;j++){
            // only connect near neighbors to keep the composition airy
            const a = anchors[i];
            const b = anchors[j];
            const dx = a.x - b.x;
            const dy = a.y - b.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if(dist < Math.max(width,height)/2.4){
              const line = document.createElementNS('http://www.w3.org/2000/svg','line');
              line.setAttribute('x1', a.x);
              line.setAttribute('y1', a.y);
              line.setAttribute('x2', b.x);
              line.setAttribute('y2', b.y);
              line.setAttribute('class','network-line');
              // vary opacity by distance
              const opacity = 0.08 * (1 - dist / (Math.max(width,height)) );
              line.style.stroke = `rgba(255,255,255,${Math.max(0.02,opacity)})`;
              svg.appendChild(line);
            }
          }
        }

        // add a few longer, fainter crossing lines for structure
        const extras = [ {x1:0.05,y1:0.1,x2:0.9,y2:0.45}, {x1:0.2,y1:0.9,x2:0.85,y2:0.15} ];
        extras.forEach(e=>{
          const l = document.createElementNS('http://www.w3.org/2000/svg','line');
          l.setAttribute('x1', Math.floor(e.x1*width));
          l.setAttribute('y1', Math.floor(e.y1*height));
          l.setAttribute('x2', Math.floor(e.x2*width));
          l.setAttribute('y2', Math.floor(e.y2*height));
          l.setAttribute('class','network-line faint');
          svg.appendChild(l);
        });

        // glowing nodes
        const nodePositions = [ anchors[7], anchors[10], anchors[15] ];
        nodePositions.forEach((p,i)=>{
          if(!p) return;
          const r = 6 + i*3;
          const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
          c.setAttribute('cx', p.x);
          c.setAttribute('cy', p.y);
          c.setAttribute('r', r);
          c.setAttribute('class','node-glow');
          c.style.opacity = 0.9 - i*0.2;
          svg.appendChild(c);
        });

        // a few faint extra nodes for depth
        anchors.slice(0,3).forEach((p,i)=>{
          const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
          c.setAttribute('cx', Math.round(p.x*0.92));
          c.setAttribute('cy', Math.round(p.y*1.02));
          c.setAttribute('r', 3);
          c.setAttribute('fill','rgba(255,255,255,0.06)');
          svg.appendChild(c);
        });
      }

      let resizeTimer;
      function rebuild(){
        // clear and rebuild
        while(svg.lastChild) svg.removeChild(svg.lastChild);
        // re-add defs
        const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
        defs.innerHTML = `\n        <filter id="softGlow" x="-50%" y="-50%" width="200%" height="200%">\n          <feGaussianBlur stdDeviation="8" result="blur" />\n          <feMerge>\n            <feMergeNode in="blur" />\n            <feMergeNode in="SourceGraphic" />\n          </feMerge>\n        </filter>\n        `;
        svg.appendChild(defs);
        createLayout();
      }

      window.addEventListener('resize', ()=>{
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(rebuild,200);
      });

      // initial build
      rebuild();

      // Optional: expose a quick exporter so you can save the background as an image
      window.exportBackgroundPNG = function(filename = 'powerbi-bg.png'){
        const box = svg.getBBox();
        const serializer = new XMLSerializer();
        const svgStr = '<?xml version="1.0" standalone="no"?>\n' + serializer.serializeToString(svg);

        // create a canvas and paint the gradient background then draw the SVG on top
        const canvas = document.createElement('canvas');
        const w = Math.max(1920, Math.round(window.innerWidth));
        const h = Math.max(1080, Math.round(window.innerHeight));
        canvas.width = w;
        canvas.height = h;
        const ctx = canvas.getContext('2d');

        // paint gradient similar to CSS
        const grad = ctx.createLinearGradient(0,0,w,h);
        grad.addColorStop(0,'#0f2b39');
        grad.addColorStop(0.35,'#2b2230');
        grad.addColorStop(0.7,'#5a1e20');
        grad.addColorStop(1,'#7b1414');
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,w,h);

        const img = new Image();
        const svgBlob = new Blob([svgStr], {type:'image/svg+xml;charset=utf-8'});
        const url = URL.createObjectURL(svgBlob);
        img.onload = function(){
          ctx.drawImage(img,0,0,w,h);
          URL.revokeObjectURL(url);
          const a = document.createElement('a');
          a.download = filename;
          a.href = canvas.toDataURL('image/png');
          a.click();
        };
        img.src = url;
      };

    })();
  </script>
</body>
</html>
